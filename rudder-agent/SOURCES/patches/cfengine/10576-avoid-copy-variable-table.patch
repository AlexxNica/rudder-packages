diff -upr cfengine-source/libpromises/eval_context.c cfengine-source-2/libpromises/eval_context.c
--- cfengine-source/libpromises/eval_context.c	2015-03-12 21:21:31.000000000 +0100
+++ cfengine-source-2/libpromises/eval_context.c	2017-04-11 15:03:42.047054384 +0200
@@ -1109,16 +1109,7 @@ void EvalContextStackPushPromiseFrame(Ev
 
     EvalContextStackPushFrame(ctx, frame);
 
-    if (copy_bundle_context)
-    {
-        frame->data.promise.vars = VariableTableCopyLocalized(ctx->global_variables,
-                                                              EvalContextStackCurrentBundle(ctx)->ns,
-                                                              EvalContextStackCurrentBundle(ctx)->name);
-    }
-    else
-    {
-        frame->data.promise.vars = VariableTableNew();
-    }
+    frame->data.promise.vars = VariableTableNew();
 
     if (PromiseGetBundle(owner)->source_path)
     {
@@ -1770,9 +1761,11 @@ static Variable *VariableResolve(const E
     }
 
     VariableTable *table = GetVariableTableForScope(ctx, ref->ns, ref->scope);
+    Variable *var;
+
     if (table)
     {
-        Variable *var = VariableTableGet(table, ref);
+        var = VariableTableGet(table, ref);
         if (var)
         {
             return var;
@@ -1790,6 +1783,17 @@ static Variable *VariableResolve(const E
         }
     }
 
+    // Try to qualify "this." variable to "current_bundle."
+    const Bundle *last_bundle = EvalContextStackCurrentBundle(ctx);
+    if (last_bundle && strcmp(ref->scope, SpecialScopeToString(SPECIAL_SCOPE_THIS)) == 0)
+    {
+        VarRef *qref = VarRefCopy(ref);
+        VarRefQualify(qref, last_bundle->ns, last_bundle->name);
+        var = VariableResolve(ctx, qref);
+        VarRefDestroy(qref);
+        return var;
+    }
+
     return NULL;
 }
 
diff -upr cfengine-source/libpromises/var_expressions.c cfengine-source-2/libpromises/var_expressions.c
--- cfengine-source/libpromises/var_expressions.c	2015-02-27 14:18:52.000000000 +0100
+++ cfengine-source-2/libpromises/var_expressions.c	2017-04-11 15:05:24.780133633 +0200
@@ -316,6 +316,17 @@ VarRef *VarRefParseFromNamespaceAndScope
 
     if (scope)
     {
+
+        /*
+         * Force considering non-special "this." variables as unqualified.
+         * This allows qualifying bundle parameters passed as reference with a "this" scope
+         * in the calling bundle.
+         */
+        if (is_this_not_special(scope, lval)) {
+            free(scope);
+            scope = NULL;
+        }
+
         if (SpecialScopeFromString(scope) != SPECIAL_SCOPE_NONE)
         {
             _ns = NULL;
@@ -342,6 +353,29 @@ VarRef *VarRefParseFromNamespaceAndScope
     return ref;
 }
 
+/*
+ * This function will return true if the given variable is
+ * a this.something variable that is an alias to a non-special local variable.
+ */
+bool is_this_not_special(const char *scope, const char *lval) {
+    // TODO: better way to get this list?
+    const char *special_this_variables[] = {"v","k","this","service_policy","promiser","promiser_uid","promiser_gid","promiser_pid","promiser_ppid","bundle","handle","namespace","promise_filename","promise_dirname","promise_linenumber", NULL};
+
+    if (!scope) {
+        return false;
+    }
+
+    if (SpecialScopeFromString(scope) != SPECIAL_SCOPE_THIS) {
+        return false;
+    }
+
+    if (IsStrIn(lval, special_this_variables)) {
+        return false;
+    }
+
+    return true;
+}
+
 VarRef *VarRefParse(const char *var_ref_string)
 {
     return VarRefParseFromNamespaceAndScope(var_ref_string, NULL, NULL, CF_NS, '.');
diff -upr cfengine-source/libpromises/var_expressions.h cfengine-source-2/libpromises/var_expressions.h
--- cfengine-source/libpromises/var_expressions.h	2014-08-29 16:44:14.000000000 +0200
+++ cfengine-source-2/libpromises/var_expressions.h	2017-04-11 15:05:41.572146586 +0200
@@ -44,6 +44,8 @@ VarRef *VarRefCopy(const VarRef *ref);
 VarRef *VarRefCopyLocalized(const VarRef *ref);
 VarRef *VarRefCopyIndexless(const VarRef *ref);
 
+bool is_this_not_special(const char *scope, const char *lval);
+
 VarRef *VarRefParse(const char *var_ref_string);
 
 /**
