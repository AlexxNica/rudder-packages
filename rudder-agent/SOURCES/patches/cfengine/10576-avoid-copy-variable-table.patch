diff --git a/libpromises/eval_context.c b/libpromises/eval_context.c
index e4f8738..8e443f0 100644
--- a/libpromises/eval_context.c
+++ b/libpromises/eval_context.c
@@ -1109,16 +1109,7 @@ void EvalContextStackPushPromiseFrame(EvalContext *ctx, const Promise *owner, bo
 
     EvalContextStackPushFrame(ctx, frame);
 
-    if (copy_bundle_context)
-    {
-        frame->data.promise.vars = VariableTableCopyLocalized(ctx->global_variables,
-                                                              EvalContextStackCurrentBundle(ctx)->ns,
-                                                              EvalContextStackCurrentBundle(ctx)->name);
-    }
-    else
-    {
-        frame->data.promise.vars = VariableTableNew();
-    }
+    frame->data.promise.vars = VariableTableNew();
 
     if (PromiseGetBundle(owner)->source_path)
     {
@@ -1770,9 +1761,11 @@ static Variable *VariableResolve(const EvalContext *ctx, const VarRef *ref)
     }
 
     VariableTable *table = GetVariableTableForScope(ctx, ref->ns, ref->scope);
+    Variable *var;
+
     if (table)
     {
-        Variable *var = VariableTableGet(table, ref);
+        var = VariableTableGet(table, ref);
         if (var)
         {
             return var;
@@ -1790,6 +1783,17 @@ static Variable *VariableResolve(const EvalContext *ctx, const VarRef *ref)
         }
     }
 
+    // Try to qualify "this." variable to "current_bundle."
+    const Bundle *last_bundle = EvalContextStackCurrentBundle(ctx);
+    if (last_bundle && strcmp(ref->scope, SpecialScopeToString(SPECIAL_SCOPE_THIS)) == 0)
+    {
+        VarRef *qref = VarRefCopy(ref);
+        VarRefQualify(qref, last_bundle->ns, last_bundle->name);
+        var = VariableResolve(ctx, qref);
+        VarRefDestroy(qref);
+        return var;
+    }
+
     return NULL;
 }
 
diff --git a/libpromises/var_expressions.c b/libpromises/var_expressions.c
index fbbe6b7..48d1042 100644
--- a/libpromises/var_expressions.c
+++ b/libpromises/var_expressions.c
@@ -320,6 +320,16 @@ VarRef *VarRefParseFromNamespaceAndScope(const char *qualified_name, const char
         {
             _ns = NULL;
         }
+
+        /*
+         * Force considering non-special "this." variables as unqualified.
+         * This allows qualifying bundle parameters passed as reference with a "this" scope
+         * in the calling bundle.
+         */
+        if (is_this_not_special(scope, lval)) {
+            free(scope);
+            scope = NULL;
+        }
     }
     else
     {
@@ -342,6 +352,29 @@ VarRef *VarRefParseFromNamespaceAndScope(const char *qualified_name, const char
     return ref;
 }
 
+/*
+ * This function will return true if the given variable is
+ * a this.something variable that is an alias to a non-special local variable.
+ */
+bool is_this_not_special(const char *scope, const char *lval) {
+    // TODO: better way to get this list?
+    const char *special_this_variables[] = {"v","k","this","service_policy","promiser","promiser_uid","promiser_gid","promiser_pid","promiser_ppid","bundle","handle","namespace","promise_filename","promise_dirname","promise_linenumber", NULL};
+
+    if (!scope) {
+        return false;
+    }
+
+    if (SpecialScopeFromString(scope) != SPECIAL_SCOPE_THIS) {
+        return false;
+    }
+
+    if (IsStrIn(lval, special_this_variables)) {
+        return false;
+    }
+
+    return true;
+}
+
 VarRef *VarRefParse(const char *var_ref_string)
 {
     return VarRefParseFromNamespaceAndScope(var_ref_string, NULL, NULL, CF_NS, '.');
diff --git a/libpromises/var_expressions.h b/libpromises/var_expressions.h
index cd9d0a8..7ea1605 100644
--- a/libpromises/var_expressions.h
+++ b/libpromises/var_expressions.h
@@ -44,6 +44,8 @@ VarRef *VarRefCopy(const VarRef *ref);
 VarRef *VarRefCopyLocalized(const VarRef *ref);
 VarRef *VarRefCopyIndexless(const VarRef *ref);
 
+bool is_this_not_special(const char *scope, const char *lval);
+
 VarRef *VarRefParse(const char *var_ref_string);
 
 /**
